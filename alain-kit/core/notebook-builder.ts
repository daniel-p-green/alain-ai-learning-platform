/**
 * ALAIN-Kit Notebook Builder
 * 
 * Assembles final Jupyter notebooks from outline and sections.
 * Ensures proper structure and Colab compatibility.
 */

import { NotebookOutline } from './outline-generator';
import { GeneratedSection } from './section-generator';
import { createLogger, trackEvent } from './obs';

export interface Assessment {
  question: string;
  options: string[];
  correct_index: number;
  explanation: string;
}

export interface Setup {
  requirements?: string[];
}

export interface JupyterNotebook {
  cells: Array<{
    cell_type: 'markdown' | 'code';
    metadata: {};
    source: string[];
  }>;
  metadata: {
    kernelspec: {
      display_name: string;
      language: string;
      name: string;
    };
    language_info: {
      name: string;
      version: string;
    };
    alain?: {
      schemaVersion: string;
      createdAt: string;
      title?: string;
      builder?: { name: string; version?: string };
    };
  };
  nbformat: number;
  nbformat_minor: number;
}

export class NotebookBuilder {
  private log = createLogger('NotebookBuilder');
  /**
   * Build complete Jupyter notebook from outline and sections
   */
  buildNotebook(outline: NotebookOutline, sections: GeneratedSection[]): JupyterNotebook {
    const started = Date.now();
    // Validate inputs
    if (!outline?.title || !outline.overview) {
      throw new Error('Invalid outline: missing title or overview');
    }
    if (!Array.isArray(sections)) {
      throw new Error('Sections must be an array');
    }
    const cells: Array<{ cell_type: 'markdown' | 'code'; metadata: {}; source: string[] }> = [];

    // Environment detection cell (Colab compatibility)
    cells.push(this.createEnvironmentCell());

    // Secret management primer + .env loader/creator
    cells.push(this.createEnvDocsCell());
    cells.push(this.createDotenvCell());

    // Provider setup (Poe-friendly OpenAI-compatible client)
    cells.push(this.createProviderSetupCell());
    // Quick provider smoke test
    cells.push(this.createProviderSmokeCell());

    // ALAIN branding (expanded name)
    cells.push(this.createBrandingCell());

    // Title and overview
    cells.push(this.createTitleCell(outline.title, outline.overview));

    // Learning objectives
    cells.push(this.createObjectivesCell(outline.objectives));

    // Prerequisites
    if (outline.prerequisites?.length > 0) {
      cells.push(this.createPrerequisitesCell(outline.prerequisites));
    }

    // Setup section
    if (outline.setup) {
      const setupCells = this.createSetupCells(outline.setup);
      setupCells.forEach(cell => cells.push(cell));
    }

    // Ensure ipywidgets is available for interactive MCQs
    cells.push({
      cell_type: "code" as const,
      metadata: {},
      source: [
        "# Ensure ipywidgets is installed for interactive MCQs\n",
        "try:\n",
        "    import ipywidgets  # type: ignore\n",
        "    print('ipywidgets available')\n",
        "except Exception:\n",
        "    import sys, subprocess\n",
        "    subprocess.check_call([sys.executable, '-m', 'pip', 'install', '-q', 'ipywidgets>=8.0.0'])\n"
      ],
      execution_count: null as any,
      outputs: [] as any[]
    } as any);

    // Generated sections
    sections.forEach(section => {
      section.content.forEach(cell => {
        const obj: any = {
          cell_type: cell.cell_type,
          metadata: {},
          source: this.formatCellSource(cell.source)
        };
        if (cell.cell_type === 'code') {
          obj.execution_count = null;
          obj.outputs = [];
        }
        cells.push(obj);
      });
    });

    // Assessments (interactive)
    if (outline.assessments?.length > 0) {
      const asses = this.createAssessmentsCells(outline.assessments);
      asses.forEach(c => cells.push(c));
    }

    // Troubleshooting guide
    cells.push(this.createTroubleshootingCell());

    const createdAt = new Date().toISOString();
    const nb = {
      cells,
      metadata: {
        kernelspec: {
          display_name: "Python 3",
          language: "python",
          name: "python3"
        },
        language_info: {
          name: "python",
          version: "3"
        },
        alain: {
          schemaVersion: "1.0.0",
          createdAt,
          title: outline.title,
          builder: { name: "alain-kit", version: "0.1.0" }
        }
      },
      nbformat: 4,
      nbformat_minor: 4
    };
    const dur = Date.now() - started;
    try { trackEvent('alain_notebook_built', { cells: cells.length, sections: sections.length, duration_ms: dur }); } catch {}
    this.log.info('timing', { op: 'buildNotebook', duration_ms: dur, cells: cells.length, sections: sections.length });
    return nb;
  }

  private createBrandingCell() {
    const createdAt = new Date().toISOString().split('T')[0];
    return {
      cell_type: "markdown" as const,
      metadata: {},
      source: [
        `> Generated by ALAIN (Applied Learning AI Notebooks) — ${createdAt}.\n`
      ]
    };
  }

  private createEnvironmentCell() {
    return {
      cell_type: "code" as const,
      metadata: {},
      source: [
        "# 🔧 Environment Detection and Setup\n",
        "import sys\n",
        "import os\n",
        "\n",
        "# Detect environment\n",
        "IN_COLAB = 'google.colab' in sys.modules\n",
        "env_label = 'Google Colab' if IN_COLAB else 'Local'\n",
        "print(f'Environment: {env_label}')\n",
        "\n",
        "# Setup environment-specific configurations\n",
        "if IN_COLAB:\n",
        "    print('📝 Colab-specific optimizations enabled')\n",
        "    try:\n",
        "        from google.colab import output\n",
        "        output.enable_custom_widget_manager()\n",
        "    except Exception:\n",
        "        pass\n"
      ],
      execution_count: null as any,
      outputs: [] as any[]
    };
  }

  private createEnvDocsCell() {
    return {
      cell_type: "markdown" as const,
      metadata: {},
      source: [
        "## API Keys and .env Files\\n\\n",
        "Many providers require API keys. Do not hardcode secrets in notebooks. Use a local .env file that the notebook loads at runtime.\\n\\n",
        "- Why .env? Keeps secrets out of source control and tutorials.\\n",
        "- Where? Place `.env.local` (preferred) or `.env` in the same folder as this notebook. `.env.local` overrides `.env`.\\n",
        "- What keys? Common: `POE_API_KEY` (Poe-compatible servers), `OPENAI_API_KEY` (OpenAI-compatible), `HF_TOKEN` (Hugging Face).\\n",
        "- Find your keys:\\n",
        "  - Poe-compatible providers: see your provider's dashboard for an API key.\\n",
        "  - Hugging Face: create a token at https://huggingface.co/settings/tokens (read scope is usually enough).\\n",
        "  - Local servers: you may not need a key; set `OPENAI_BASE_URL` instead (e.g., http://localhost:1234/v1).\\n\\n",
        "The next cell will: load `.env.local`/`.env`, prompt for missing keys, and optionally write `.env.local` with secure permissions so future runs just work."
      ]
    };
  }

  private createDotenvCell() {
    return {
      cell_type: "code" as const,
      metadata: {},
      source: [
        "# 🔐 Load and manage secrets from .env\\n",
        "# This cell will: (1) load .env.local/.env, (2) prompt for missing keys, (3) optionally write .env.local (0600).\\n",
        "# Location: place your .env files next to this notebook (recommended) or at project root.\\n",
        "# Disable writing: set SAVE_TO_ENV = False below.\\n",
        "import os, pathlib\\n",
        "from getpass import getpass\\n",
        "\\n",
        "# Install python-dotenv if missing\\n",
        "try:\\n",
        "    import dotenv  # type: ignore\\n",
        "except Exception:\\n",
        "    import sys, subprocess\\n",
        "    if 'IN_COLAB' in globals() and IN_COLAB:\\n",
        "        try:\\n",
        "            import IPython\\n",
        "            ip = IPython.get_ipython()\\n",
        "            if ip is not None:\\n",
        "                ip.run_line_magic('pip', 'install -q python-dotenv>=1.0.0')\\n",
        "            else:\\n",
        "                subprocess.check_call([sys.executable, '-m', 'pip', 'install', '-q', 'python-dotenv>=1.0.0'])\\n",
        "        except Exception as colab_exc:\\n",
        "            print('⚠️ Colab pip fallback failed:', colab_exc)\\n",
        "            raise\\n",
        "    else:\\n",
        "        subprocess.check_call([sys.executable, '-m', 'pip', 'install', '-q', 'python-dotenv>=1.0.0'])\\n",
        "    import dotenv  # type: ignore\\n",
        "\\n",
        "# Prefer .env.local over .env\\n",
        "cwd = pathlib.Path.cwd()\\n",
        "env_local = cwd / '.env.local'\\n",
        "env_file = cwd / '.env'\\n",
        "chosen = env_local if env_local.exists() else (env_file if env_file.exists() else None)\\n",
        "if chosen:\\n",
        "    dotenv.load_dotenv(dotenv_path=str(chosen))\\n",
        "    print(f'Loaded env from {chosen.name}')\\n",
        "else:\\n",
        "    print('No .env.local or .env found; will prompt for keys.')\\n",
        "\\n",
        "# Keys we might use in this notebook\\n",
        "keys = ['POE_API_KEY', 'OPENAI_API_KEY', 'HF_TOKEN']\\n",
        "missing = [k for k in keys if not os.environ.get(k)]\\n",
        "for k in missing:\\n",
        "    val = getpass(f'Enter {k} (hidden, press Enter to skip): ')\\n",
        "    if val:\\n",
        "        os.environ[k] = val\\n",
        "\\n",
        "# Decide whether to persist to .env.local for convenience\\n",
        "SAVE_TO_ENV = True  # set False to disable writing\\n",
        "if SAVE_TO_ENV:\\n",
        "    target = env_local\\n",
        "    existing = {}\\n",
        "    if target.exists():\\n",
        "        try:\\n",
        "            for line in target.read_text().splitlines():\\n",
        "                if not line.strip() or line.strip().startswith('#') or '=' not in line:\\n",
        "                    continue\\n",
        "                k,v = line.split('=',1)\\n",
        "                existing[k.strip()] = v.strip()\\n",
        "        except Exception:\\n",
        "            pass\\n",
        "    for k in keys:\\n",
        "        v = os.environ.get(k)\\n",
        "        if v:\\n",
        "            existing[k] = v\\n",
        "    lines = []\\n",
        "    for k,v in existing.items():\\n",
        "        # Always quote; escape backslashes and double quotes for safety\\n",
        "        escaped = v.replace(\"\\\\\", \"\\\\\\\\\")\\n",
        "        escaped = escaped.replace(\"\\\"\", \"\\\\\"\")\\n",
        "        vv = f'\"{escaped}\"'\\n",
        "        lines.append(f\"{k}={vv}\")\\n",
        "    target.write_text('\\\\n'.join(lines) + '\\\\n')\\n",
        "    try:\\n",
        "        target.chmod(0o600)  # 600\\n",
        "    except Exception:\\n",
        "        pass\\n",
        "    print(f'🔏 Wrote secrets to {target.name} (permissions 600)')\\n",
        "\\n",
        "# Simple recap (masked)\\n",
        "def mask(v):\\n",
        "    if not v: return '∅'\\n",
        "    return v[:3] + '…' + v[-2:] if len(v) > 6 else '•••'\\n",
        "for k in keys:\\n",
        "    print(f'{k}:', mask(os.environ.get(k)))\\n"
      ],
      execution_count: null as any,
      outputs: [] as any[]
    } as any;
  }

  private createProviderSetupCell() {
    return {
      cell_type: "code" as const,
      metadata: {},
      source: [
        "# 🌐 ALAIN Provider Setup (Poe/OpenAI-compatible)\n",
        "# About keys: If you have POE_API_KEY, this cell maps it to OPENAI_API_KEY and sets OPENAI_BASE_URL to Poe.\n",
        "# Otherwise, set OPENAI_API_KEY (and optionally OPENAI_BASE_URL for local/self-hosted servers).\n",
        "import os\n",
        "try:\n",
        "    # Prefer Poe; fall back to OPENAI_API_KEY if set\n",
        "    poe = os.environ.get('POE_API_KEY')\n",
        "    if poe:\n",
        "        os.environ.setdefault('OPENAI_BASE_URL', 'https://api.poe.com/v1')\n",
        "        os.environ.setdefault('OPENAI_API_KEY', poe)\n",
        "    # Prompt if no key present\n",
        "    if not os.environ.get('OPENAI_API_KEY'):\n",
        "        from getpass import getpass\n",
        "        os.environ['OPENAI_API_KEY'] = getpass('Enter POE_API_KEY (input hidden): ')\n",
        "        os.environ.setdefault('OPENAI_BASE_URL', 'https://api.poe.com/v1')\n",
        "    # Ensure openai client is installed\n",
        "    try:\n",
        "        from openai import OpenAI  # type: ignore\n",
        "    except Exception:\n",
        "        import sys, subprocess\n",
        "        subprocess.check_call([sys.executable, '-m', 'pip', 'install', '-q', 'openai>=1.34.0'])\n",
        "        from openai import OpenAI  # type: ignore\n",
        "    # Create client\n",
        "    from openai import OpenAI\n",
        "    client = OpenAI(base_url=os.environ['OPENAI_BASE_URL'], api_key=os.environ['OPENAI_API_KEY'])\n",
        "    print('✅ Provider ready:', os.environ.get('OPENAI_BASE_URL'))\n",
        "except Exception as e:\n",
        "    print('⚠️ Provider setup failed:', e)\n"
      ],
      execution_count: null as any,
      outputs: [] as any[]
    };
  }

  private createProviderSmokeCell() {
    return {
      cell_type: "code" as const,
      metadata: {},
      source: [
        "# 🔎 Provider Smoke Test (1-token)\n",
        "import os\n",
        "model = os.environ.get('ALAIN_MODEL') or 'gpt-4o-mini'\n",
        "if 'client' not in globals():\n",
        "    print('⚠️ Provider client not available; skipping smoke test')\n",
        "else:\n",
        "    try:\n",
        "        resp = client.chat.completions.create(model=model, messages=[{\"role\":\"user\",\"content\":\"ping\"}], max_tokens=1)\n",
        "        print('✅ Smoke OK:', resp.choices[0].message.content)\n",
        "    except Exception as e:\n",
        "        print('⚠️ Smoke test failed:', e)\n"
      ],
      execution_count: null as any,
      outputs: [] as any[]
    };
  }

  private createTitleCell(title: string, overview: string) {
    return {
      cell_type: "markdown" as const,
      metadata: {},
      source: [`# ${title}\n\n${overview}`]
    };
  }

  private createObjectivesCell(objectives: string[]) {
    return {
      cell_type: "markdown" as const,
      metadata: {},
      source: [
        "## Learning Objectives\n\n",
        "By the end of this tutorial, you will be able to:\n\n",
        ...objectives.map((obj, i) => `${i + 1}. ${obj}\n`)
      ]
    };
  }

  private createPrerequisitesCell(prerequisites: string[]) {
    return {
      cell_type: "markdown" as const,
      metadata: {},
      source: [
        "## Prerequisites\n\n",
        ...prerequisites.map(prereq => `- ${prereq}\n`)
      ]
    };
  }

  private createSetupCells(setup: Setup): Array<{ cell_type: 'markdown' | 'code'; metadata: {}; source: string[] }> {
    const cells: Array<{ cell_type: 'markdown' | 'code'; metadata: {}; source: string[] }> = [
      {
        cell_type: "markdown" as const,
        metadata: {},
        source: ["## Setup\n\nLet's install the required packages and set up our environment.\n"]
      }
    ];

    if (setup.requirements && setup.requirements.length > 0) {
      cells.push({
        cell_type: "code" as const,
        metadata: {},
        source: [
          "# Install packages (Colab-compatible)\n",
          "# Check if we're in Colab\n",
          "import sys\n",
          "IN_COLAB = 'google.colab' in sys.modules\n",
          "\n",
          "if IN_COLAB:\n",
          `    !pip install -q ${setup.requirements.join(' ')}\n`,
          "else:\n",
          "    import subprocess\n",
          `    subprocess.check_call([sys.executable, '-m', 'pip', 'install'] + ${JSON.stringify(setup.requirements)})\n`,
          "\n",
          "print('✅ Packages installed!')"
        ]
      });
    }

    return cells;
  }

  private createAssessmentsCells(assessments: Assessment[]) {
    const cells: Array<{ cell_type: 'markdown' | 'code'; metadata: {}; source: string[] }> = [];
    cells.push({
      cell_type: 'markdown' as const,
      metadata: {},
      source: [
        '## Knowledge Check (Interactive)\n\n',
        'Use the widgets below to select an answer and click Grade to see feedback.\n'
      ]
    });
    cells.push({
      cell_type: 'code' as const,
      metadata: {},
      source: [
        '# MCQ helper (ipywidgets)\n',
        'import ipywidgets as widgets\n',
        'from IPython.display import display, Markdown\n\n',
        'def render_mcq(question, options, correct_index, explanation):\n',
        "    # Use (label, value) so rb.value is the numeric index\n",
        "    rb = widgets.RadioButtons(options=[(f'{chr(65+i)}. '+opt, i) for i,opt in enumerate(options)], description='')\n",
        "    grade_btn = widgets.Button(description='Grade', button_style='primary')\n",
        "    feedback = widgets.HTML(value='')\n",
        '    def on_grade(_):\n',
        '        sel = rb.value\n',
        "        if sel is None:\n            feedback.value = '<p>⚠️ Please select an option.</p>'\n            return\n",
        '        if sel == correct_index:\n',
        "            feedback.value = '<p>✅ Correct!</p>'\n",
        '        else:\n',
        "            feedback.value = f'<p>❌ Incorrect. Correct answer is {chr(65+correct_index)}.</p>'\n",
        "        feedback.value += f'<div><em>Explanation:</em> {explanation}</div>'\n",
        '    grade_btn.on_click(on_grade)\n',
        "    display(Markdown('### '+question))\n",
        '    display(rb)\n',
        '    display(grade_btn)\n',
        '    display(feedback)\n'
      ],
      execution_count: null as any,
      outputs: [] as any[]
    } as any);
    assessments.forEach((mcq, i) => {
      // Validate MCQ structure
      if (!mcq.question || !Array.isArray(mcq.options) || typeof mcq.correct_index !== 'number' || !mcq.explanation) {
        console.warn(`Skipping invalid MCQ at index ${i}:`, mcq);
        return;
      }
      if (mcq.correct_index < 0 || mcq.correct_index >= mcq.options.length) {
        console.warn(`Skipping MCQ with out-of-range correct_index at ${i}`);
        return;
      }
      
      try {
        const call = `render_mcq(${JSON.stringify(mcq.question)}, ${JSON.stringify(mcq.options)}, ${mcq.correct_index}, ${JSON.stringify(mcq.explanation)})\n`;
        cells.push({ cell_type: 'code' as const, metadata: {}, source: [call], execution_count: null as any, outputs: [] as any[] } as any);
      } catch (error) {
        console.warn(`Failed to serialize MCQ at index ${i}:`, error);
      }
    });
    return cells;
  }

  private createTroubleshootingCell() {
    return {
      cell_type: "markdown" as const,
      metadata: {},
      source: [
        "## 🔧 Troubleshooting Guide\n\n",
        "### Common Issues:\n\n",
        "1. **Out of Memory Error**\n",
        "   - Enable GPU: Runtime → Change runtime type → GPU\n",
        "   - Restart runtime if needed\n\n",
        "2. **Package Installation Issues**\n",
        "   - Restart runtime after installing packages\n",
        "   - Use `!pip install -q` for quiet installation\n\n",
        "3. **Model Loading Fails**\n",
        "   - Check internet connection\n",
        "   - Verify authentication tokens\n",
        "   - Try CPU-only mode if GPU fails\n"
      ]
    };
  }

  private formatCellSource(source: string | string[]): string[] {
    if (Array.isArray(source)) return source.map(s => (s.endsWith('\n') ? s : s + '\n'));
    return String(source || '').split('\n').map(line => line + '\n');
  }
}
