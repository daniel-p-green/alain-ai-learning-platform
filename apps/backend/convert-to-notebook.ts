#!/usr/bin/env tsx
/**
 * Convert GPT-OSS model responses to proper .ipynb notebook files
 */

import { readFileSync, writeFileSync } from 'fs';
import { join } from 'path';
import { buildNotebook } from './export/notebook';

function extractNotebookContent(apiResponse: any): string {
  const content = apiResponse?.choices?.[0]?.message?.content || '';
  
  // Extract the actual notebook content from the thinking process
  const lines = content.split('\n');
  let notebookStart = -1;
  
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].includes('```python') || lines[i].includes('# %%') || lines[i].includes('# %% [markdown]')) {
      notebookStart = i;
      break;
    }
  }
  
  if (notebookStart === -1) {
    // Look for structured content after thinking
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].includes('# ') && lines[i].length > 10) {
        notebookStart = i;
        break;
      }
    }
  }
  
  return notebookStart >= 0 ? lines.slice(notebookStart).join('\n') : content;
}

function parseNotebookFromText(content: string, title: string, model: string): any {
  const cells: any[] = [];
  const lines = content.split('\n');
  let currentCell: any = null;
  let cellContent: string[] = [];
  
  // Add attribution cell
  const creationDate = new Date().toISOString().split('T')[0];
  cells.push({
    cell_type: "markdown",
    metadata: {},
    source: [
      `<!-- \n`,
      `Generated by ALAIN (Applied Learning AI Notebooks) on ${creationDate}\n`,
      `Teacher Model: ${model.toUpperCase()}\n`,
      `Provider: poe\n`,
      `Target Model: ${model}\n`,
      `Learn more: https://github.com/daniel-p-green/alain-ai-learning-platform/\n`,
      `-->\n`
    ]
  });

  // Visible banner to match CLI exports
  cells.push({
    cell_type: "markdown",
    metadata: {},
    source: [`> Generated by ALAIN (Applied Learning AI Notebooks) — ${creationDate}.\n`]
  });
  
  // Add title cell
  cells.push({
    cell_type: "markdown",
    metadata: {},
    source: [`# ${title}\n\n`, `Generated using ${model.toUpperCase()} model\n\n`]
  });
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Detect cell boundaries
    if (line.startsWith('# %% [markdown]') || line.startsWith('# %%[markdown]')) {
      if (currentCell) {
        currentCell.source = cellContent;
        cells.push(currentCell);
      }
      currentCell = { cell_type: "markdown", metadata: {}, source: [] };
      cellContent = [];
    } else if (line.startsWith('# %%') && !line.includes('markdown')) {
      if (currentCell) {
        currentCell.source = cellContent;
        cells.push(currentCell);
      }
      currentCell = { cell_type: "code", metadata: {}, source: [], outputs: [], execution_count: null };
      cellContent = [];
    } else if (line.startsWith('```python')) {
      if (currentCell) {
        currentCell.source = cellContent;
        cells.push(currentCell);
      }
      currentCell = { cell_type: "code", metadata: {}, source: [], outputs: [], execution_count: null };
      cellContent = [];
    } else if (line.startsWith('```') && currentCell?.cell_type === 'code') {
      currentCell.source = cellContent;
      cells.push(currentCell);
      currentCell = null;
      cellContent = [];
    } else if (line.startsWith('# ') && line.length > 10 && !currentCell) {
      // Start a markdown cell for headers
      currentCell = { cell_type: "markdown", metadata: {}, source: [] };
      cellContent = [line + '\n'];
    } else if (currentCell) {
      cellContent.push(line + '\n');
    } else if (line.trim()) {
      // Default to markdown for standalone content
      cells.push({
        cell_type: "markdown",
        metadata: {},
        source: [line + '\n']
      });
    }
  }
  
  // Add final cell if exists
  if (currentCell && cellContent.length > 0) {
    currentCell.source = cellContent;
    cells.push(currentCell);
  }
  
  return {
    cells,
    metadata: {
      kernelspec: { name: "python3", language: "python", display_name: "Python 3" },
      language_info: { name: "python" },
      teacher_model_used: model.toUpperCase(),
      title: title,
      provider: "poe",
      model: model,
    },
    nbformat: 4,
    nbformat_minor: 5,
  };
}

async function convertResponseToNotebook() {
  console.log('🔄 Converting API responses to .ipynb notebooks...\n');
  
  const files = [
    {
      input: 'test-results-120b-lesson.json',
      output: 'gpt-oss-120b-transformer-lesson.ipynb',
      title: 'Transformer Architecture Deep Dive',
      model: 'gpt-oss-120b'
    },
    {
      input: 'test-results-120b-research.json',
      output: 'gpt-oss-120b-attention-paper-analysis.ipynb',
      title: 'Attention Is All You Need - Paper Analysis',
      model: 'gpt-oss-120b'
    },
    {
      input: 'test-results-120b-notebook.json',
      output: 'gpt-oss-120b-multimodal-clip.ipynb',
      title: 'Multi-modal AI: Vision-Language Models (CLIP)',
      model: 'gpt-oss-120b'
    }
  ];
  
  for (const file of files) {
    try {
      console.log(`📝 Processing ${file.input}...`);
      
      const apiResponse = JSON.parse(readFileSync(file.input, 'utf-8'));
      const content = extractNotebookContent(apiResponse);
      
      console.log(`📄 Content length: ${content.length} characters`);
      console.log(`🎯 Title: ${file.title}`);
      
      // Create proper notebook structure
      const notebook = parseNotebookFromText(content, file.title, file.model);
      
      // Save as .ipynb
      writeFileSync(file.output, JSON.stringify(notebook, null, 2));
      console.log(`✅ Created ${file.output} with ${notebook.cells.length} cells\n`);
      
    } catch (error) {
      console.error(`❌ Failed to process ${file.input}:`, error);
    }
  }
  
  console.log('🎉 Notebook conversion completed!');
  console.log('\n📋 Generated Files:');
  files.forEach(f => console.log(`  • ${f.output}`));
}

convertResponseToNotebook();
