{
  "section_number": 4,
  "title": "Step 4: Stream Chat Responses from Poe",
  "estimated_tokens": 520,
  "callouts": [
    {
      "type": "tip",
      "message": "We stream Server-Sent Events (SSE) so readers can watch completions unfold in real time."
    }
  ],
  "content": [
    {
      "cell_type": "markdown",
      "source": "Time to wire the backend. We expose a `/api/chat` route that validates model IDs, forwards messages to Poe using the OpenAI SDK, and streams deltas back as SSE. On the client, `ChatWindow` consumes the stream, updates the UI incrementally, and prepares telemetry records."
    },
    {
      "cell_type": "code",
      "source": "%%bash\nset -euo pipefail\ncat <<'EOF' > poe-chat-tutorial/lib/telemetry.ts\nexport type ChatTelemetry = {\n  id: string;\n  model: string;\n  startedAt: string;\n  latencyMs: number;\n  promptTokens: number;\n  completionTokens: number;\n  totalTokens: number;\n  status: \"success\" | \"error\";\n  errorMessage?: string;\n};\n\nexport function createTelemetryId(): string {\n  return `evt_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`;\n}\nEOF\ncat <<'EOF' > poe-chat-tutorial/components/ChatWindow.tsx\n\"use client\";\n\nimport { useCallback, useMemo, useRef, useState } from \"react\";\nimport type { PoeModelId } from \"@/lib/models\";\nimport type { ChatTelemetry } from \"@/lib/telemetry\";\nimport { createTelemetryId } from \"@/lib/telemetry\";\n\ntype ChatWindowProps = {\n  model: PoeModelId;\n  onTelemetry: (entry: ChatTelemetry) => void;\n};\n\ntype ChatMessage = {\n  id: string;\n  role: \"user\" | \"assistant\" | \"system\";\n  content: string;\n};\n\nfunction extractEvents(buffer: string): { events: Array<Record<string, unknown>>; rest: string } {\n  const events: Array<Record<string, unknown>> = [];\n  let remainder = buffer;\n  let boundaryIndex = remainder.indexOf(\"\\n\\n\");\n\n  while (boundaryIndex !== -1) {\n    const raw = remainder.slice(0, boundaryIndex).trim();\n    remainder = remainder.slice(boundaryIndex + 2);\n    if (raw.startsWith(\"data:\")) {\n      const payload = raw.replace(/^data:\\s*/, \"\");\n      if (payload) {\n        try {\n          events.push(JSON.parse(payload));\n        } catch (error) {\n          console.warn(\"Failed to parse SSE payload\", error);\n        }\n      }\n    }\n    boundaryIndex = remainder.indexOf(\"\\n\\n\");\n  }\n\n  return { events, rest: remainder };\n}\n\nexport function ChatWindow({ model, onTelemetry }: ChatWindowProps) {\n  const [messages, setMessages] = useState<ChatMessage[]>([]);\n  const [input, setInput] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const controllerRef = useRef<AbortController | null>(null);\n\n  const resetConversation = useCallback(() => {\n    controllerRef.current?.abort();\n    controllerRef.current = null;\n    setMessages([]);\n    setError(null);\n  }, []);\n\n  const chatTranscript = useMemo(() => {\n    return messages.map((message) => ({ role: message.role, content: message.content }));\n  }, [messages]);\n\n  const handleSubmit = useCallback(async () => {\n    if (!input.trim()) return;\n    if (isLoading) return;\n\n    const prompt = input.trim();\n    setInput(\"\");\n    setError(null);\n    setIsLoading(true);\n\n    const telemetryId = createTelemetryId();\n    const startedAt = new Date();\n    const highResStart = performance.now();\n    let promptTokens = 0;\n    let completionTokens = 0;\n    let errorMessage: string | undefined;\n\n    const userMessage: ChatMessage = {\n      id: `${telemetryId}-user`,\n      role: \"user\",\n      content: prompt\n    };\n\n    const assistantMessageId = `${telemetryId}-assistant`;\n\n    setMessages((current) => [\n      ...current,\n      userMessage,\n      {\n        id: assistantMessageId,\n        role: \"assistant\",\n        content: \"\"\n      }\n    ]);\n\n    const abortController = new AbortController();\n    controllerRef.current = abortController;\n\n    try {\n      const response = await fetch(\"/api/chat\", {\n        method: \"POST\",\n        body: JSON.stringify({\n          messages: [...chatTranscript, { role: \"user\", content: prompt }],\n          model\n        }),\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        signal: abortController.signal\n      });\n\n      if (!response.ok) {\n        throw new Error(`Request failed with status ${response.status}`);\n      }\n\n      if (!response.body) {\n        throw new Error(\"Response body missing\");\n      }\n\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder();\n      let buffer = \"\";\n      let assistantContent = \"\";\n\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n        buffer += decoder.decode(value, { stream: true });\n        const { events, rest } = extractEvents(buffer);\n        buffer = rest;\n\n        for (const event of events) {\n          const type = event.type;\n          if (type === \"delta\" && typeof event.content === \"string\") {\n            assistantContent += event.content;\n            setMessages((current) =>\n              current.map((message) =>\n                message.id === assistantMessageId\n                  ? { ...message, content: assistantContent }\n                  : message\n              )\n            );\n          }\n          if (type === \"usage\" && typeof event.usage === \"object\" && event.usage !== null) {\n            const usage = event.usage as Record<string, number>;\n            promptTokens = usage.prompt_tokens ?? promptTokens;\n            completionTokens = usage.completion_tokens ?? completionTokens;\n          }\n          if (type === \"error\" && typeof event.message === \"string\") {\n            errorMessage = event.message;\n            setError(event.message);\n          }\n        }\n      }\n\n      if (assistantContent.trim().length === 0) {\n        setMessages((current) =>\n          current.map((message) =>\n            message.id === assistantMessageId\n              ? { ...message, content: \"(No response received from Poe.)\" }\n              : message\n          )\n        );\n      }\n\n      onTelemetry({\n        id: telemetryId,\n        model,\n        startedAt: startedAt.toISOString(),\n        latencyMs: Math.round(performance.now() - highResStart),\n        promptTokens,\n        completionTokens,\n        totalTokens: promptTokens + completionTokens,\n        status: errorMessage ? \"error\" : \"success\",\n        errorMessage\n      });\n    } catch (fetchError) {\n      const message = fetchError instanceof Error ? fetchError.message : \"Unknown error\";\n      setError(message);\n      onTelemetry({\n        id: telemetryId,\n        model,\n        startedAt: startedAt.toISOString(),\n        latencyMs: Math.round(performance.now() - highResStart),\n        promptTokens,\n        completionTokens,\n        totalTokens: promptTokens + completionTokens,\n        status: \"error\",\n        errorMessage: message\n      });\n    } finally {\n      setIsLoading(false);\n      controllerRef.current = null;\n    }\n  }, [chatTranscript, input, isLoading, model, onTelemetry]);\n\n  return (\n    <section className=\"card\">\n      <header style={{ display: \"flex\", justifyContent: \"space-between\", alignItems: \"center\" }}>\n        <div>\n          <strong>Poe Chat Playground</strong>\n          <p style={{ margin: \"0.25rem 0\", color: \"#94a3b8\" }}>\n            Send a message, stream back the teacher response, and capture telemetry for every turn.\n          </p>\n        </div>\n        <div style={{ display: \"flex\", gap: \"0.75rem\" }}>\n          <button\n            type=\"button\"\n            onClick={resetConversation}\n            disabled={isLoading || messages.length === 0}\n            style={{\n              padding: \"0.5rem 0.85rem\",\n              borderRadius: \"10px\",\n              border: \"1px solid rgba(148, 163, 184, 0.35)\",\n              background: \"transparent\",\n              color: \"#94a3b8\",\n              cursor: \"pointer\"\n            }}\n          >\n            Reset\n          </button>\n        </div>\n      </header>\n\n      <div className=\"callout\" style={{ marginTop: \"1rem\" }}>\n        <strong>Tip:</strong> Try instructing the assistant to explain how to evaluate a model or provide debugging checklists\u2014longer answers showcase streaming feedback.\n      </div>\n\n      <div className=\"chat-container\" aria-live=\"polite\">\n        {messages.length === 0 ? (\n          <p style={{ color: \"#64748b\" }}>No messages yet. Start by sending a prompt.</p>\n        ) : (\n          messages.map((message) => (\n            <article key={message.id} className=\"chat-message\">\n              <strong>{message.role === \"user\" ? \"You\" : \"Teacher\"}</strong>\n              <span>{message.content}</span>\n            </article>\n          ))\n        )}\n      </div>\n\n      <label htmlFor=\"chat-input\" style={{ display: \"block\", marginTop: \"1rem\" }}>\n        Prompt\n      </label>\n      <textarea\n        id=\"chat-input\"\n        value={input}\n        onChange={(event) => setInput(event.target.value)}\n        placeholder=\"Ask for a lesson outline, code review checklist, or debugging tips...\"\n        disabled={isLoading}\n      />\n      <div style={{ marginTop: \"0.75rem\", display: \"flex\", gap: \"1rem\", alignItems: \"center\" }}>\n        <button\n          type=\"button\"\n          onClick={handleSubmit}\n          disabled={isLoading}\n          style={{\n            padding: \"0.75rem 1.25rem\",\n            borderRadius: \"12px\",\n            border: \"none\",\n            background: isLoading ? \"rgba(148, 163, 184, 0.2)\" : \"#38bdf8\",\n            color: isLoading ? \"#cbd5f5\" : \"#0f172a\",\n            fontWeight: 600,\n            cursor: isLoading ? \"not-allowed\" : \"pointer\"\n          }}\n        >\n          {isLoading ? \"Streaming\u2026\" : \"Send\"}\n        </button>\n        {error && <span style={{ color: \"#f97316\" }}>\u26a0\ufe0f {error}</span>}\n      </div>\n    </section>\n  );\n}\nEOF\ncat <<'EOF' > poe-chat-tutorial/app/api/chat/route.ts\nimport { NextRequest } from \"next/server\";\nimport OpenAI from \"openai\";\nimport { poeModels, type PoeModelId, isAllowedModel } from \"@/lib/models\";\n\nconst POE_BASE_URL = process.env.POE_BASE_URL ?? \"https://api.poe.com/v1\";\nconst POE_API_KEY = process.env.POE_API_KEY ?? process.env.OPENAI_API_KEY ?? \"\";\n\nif (!POE_API_KEY) {\n  console.warn(\"\u26a0\ufe0f Missing POE_API_KEY or OPENAI_API_KEY. Set it before using the chat endpoint.\");\n}\n\nconst poeClient = new OpenAI({\n  apiKey: POE_API_KEY,\n  baseURL: POE_BASE_URL\n});\n\nconst MODEL_FALLBACK: PoeModelId = \"gpt-oss-20b\";\n\nexport async function POST(request: NextRequest) {\n  const requestStartedAt = Date.now();\n  try {\n    const body = await request.json();\n    const { messages, model } = body as {\n      messages?: Array<{ role: \"user\" | \"assistant\" | \"system\"; content: string }>;\n      model?: string;\n    };\n\n    if (!Array.isArray(messages) || messages.length === 0) {\n      return new Response(\n        JSON.stringify({ error: \"Request must include at least one message.\" }),\n        { status: 400, headers: { \"Content-Type\": \"application/json\" } }\n      );\n    }\n\n    const selectedModel: PoeModelId = isAllowedModel(model) ? model : MODEL_FALLBACK;\n\n    const completion = await poeClient.chat.completions.create({\n      model: selectedModel,\n      messages,\n      stream: true,\n      max_tokens: 600,\n      temperature: 0.7\n    });\n\n    const encoder = new TextEncoder();\n    const stream = new ReadableStream({\n      async start(controller) {\n        const usageTotals = { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0 };\n        try {\n          for await (const chunk of completion) {\n            const choice = chunk.choices?.[0];\n            if (choice?.delta?.content) {\n              const payload = JSON.stringify({\n                type: \"delta\",\n                content: choice.delta.content,\n                model: selectedModel\n              });\n              controller.enqueue(encoder.encode(`data: ${payload}\\n\\n`));\n            }\n            if (chunk.usage) {\n              usageTotals.prompt_tokens = chunk.usage.prompt_tokens ?? usageTotals.prompt_tokens;\n              usageTotals.completion_tokens = chunk.usage.completion_tokens ?? usageTotals.completion_tokens;\n              usageTotals.total_tokens = chunk.usage.total_tokens ?? usageTotals.total_tokens;\n            }\n          }\n          controller.enqueue(\n            encoder.encode(\n              `data: ${JSON.stringify({\n                type: \"usage\",\n                usage: usageTotals,\n                elapsedMs: Date.now() - requestStartedAt\n              })}\\n\\n`\n            )\n          );\n          controller.enqueue(encoder.encode(`data: ${JSON.stringify({ type: \"done\" })}\\n\\n`));\n          controller.close();\n        } catch (error) {\n          controller.enqueue(\n            encoder.encode(\n              `data: ${JSON.stringify({\n                type: \"error\",\n                message: error instanceof Error ? error.message : \"Unknown streaming error\"\n              })}\\n\\n`\n            )\n          );\n          controller.close();\n        }\n      }\n    });\n\n    return new Response(stream, {\n      headers: {\n        \"Content-Type\": \"text/event-stream\",\n        \"Cache-Control\": \"no-cache\",\n        Connection: \"keep-alive\"\n      }\n    });\n  } catch (error) {\n    const message = error instanceof Error ? error.message : \"Unexpected server error\";\n    console.error(\"Poe chat error\", message);\n    return new Response(JSON.stringify({ error: message }), {\n      status: 500,\n      headers: { \"Content-Type\": \"application/json\" }\n    });\n  }\n}\n\nexport function getModelMetadata() {\n  return poeModels.map(({ id, label, description, recommended }) => ({\n    id,\n    label,\n    description,\n    recommended\n  }));\n}\nEOF"
    },
    {
      "cell_type": "markdown",
      "source": "Render the chat window and show the most recent telemetry reading so we can confirm streaming works before polishing the dashboard:"
    },
    {
      "cell_type": "code",
      "source": "%%bash\nset -euo pipefail\ncat <<'EOF' > poe-chat-tutorial/app/page.tsx\n\"use client\";\n\nimport { useState } from \"react\";\nimport { ModelSelector } from \"@/components/ModelSelector\";\nimport { ChatWindow } from \"@/components/ChatWindow\";\nimport type { PoeModelId } from \"@/lib/models\";\nimport type { ChatTelemetry } from \"@/lib/telemetry\";\n\nconst defaultModel: PoeModelId = (process.env.NEXT_PUBLIC_POE_DEFAULT_MODEL as PoeModelId) ?? \"gpt-oss-20b\";\n\nexport default function HomePage() {\n  const [model, setModel] = useState<PoeModelId>(defaultModel);\n  const [lastTelemetry, setLastTelemetry] = useState<ChatTelemetry | null>(null);\n\n  return (\n    <>\n      <section className=\"card\">\n        <h1 style={{ fontSize: \"2rem\", marginBottom: \"0.5rem\" }}>Stream Poe Responses</h1>\n        <p style={{ color: \"#94a3b8\" }}>\n          Send a prompt to the selected teacher and watch streaming text arrive directly in the UI.\n        </p>\n      </section>\n\n      <ModelSelector value={model} onChange={setModel} disabled={false} />\n\n      <ChatWindow model={model} onTelemetry={setLastTelemetry} />\n\n      <section className=\"card\">\n        <strong>Latest Telemetry</strong>\n        <p style={{ marginTop: \"0.5rem\", color: \"#94a3b8\" }}>\n          {lastTelemetry ? (\n            <span>\n              {lastTelemetry.model} \u00b7 {lastTelemetry.latencyMs} ms \u00b7 tokens: {lastTelemetry.totalTokens}\n            </span>\n          ) : (\n            <span>No telemetry yet. Send a prompt to populate this block.</span>\n          )}\n        </p>\n      </section>\n    </>\n  );\n}\nEOF"
    }
  ]
}
